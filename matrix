#include <iostream>
#include <map>
#include <tuple>

template<typename T, int default_number>
class Matrix {
public:
    class IntAdapter {
    friend class Matrix;
    public:
        IntAdapter(Matrix &parent, int row, int col) : 
            parent(parent),
            row(row),
            col(col)
        { }
        operator int() { 
            if ( parent.mat.find(row) != parent.mat.end() )
                 {
                     if ( parent.mat[row].find(col) != parent.mat[row].end()) {
                         return parent.mat[row][col];
                     }
                }
            return default_number;
        }
        int& operator =(const int &a) 
        {
            if (a == default_number)
             {
                  if ( parent.mat.find(row) != parent.mat.end() )
                 {
                     if ( parent.mat[row].find(col) != parent.mat[row].end()) {
                         parent.mat[row].erase(col);
                         if (parent.mat[row].size() == 0)
                            parent.mat.erase(row);
                     }
                }
             }
            else
            {
                //std::cout << "don't equal" << std::endl;
                parent.mat[row][col] = a;
            }
            return (int&)a;
        }
    private:
        Matrix& parent;
        int row;
        int col;
    };
    class RowProxy {
    friend class Matrix;
    public:
        RowProxy(Matrix &parent, int row) : 
            parent(parent),
            row(row)
        { }
        
        IntAdapter operator[](int col)
        {
             if ( parent.mat.find(row) != parent.mat.end() )
             {
                 if ( parent.mat[row].find(col) != parent.mat[row].end()) {
                    // std::cout << "exist" << std::endl;
                     return IntAdapter(parent, row, col);
                 }
            }
            return IntAdapter(parent, row, col);
        }
    private:
        Matrix& parent;
        int row;
    };
    
    int size() {
        int size = 0;
        for(const auto& row : mat)
        {
            size += row.second.size();   
        }
        return size;
    }
    RowProxy operator[](int row)
    {
        return RowProxy(*this, row);
    }
    std::tuple<int, int, int> begin() {
        auto it = mat.begin();
        int a = it->first;
        auto it2 = it->second.begin();
        int b = it2->first;
        int c = it2->second;
        return std::make_tuple(a, b, c);
    }
    std::map<int, std::map<int, int>> mat;
};


int main() {
    Matrix<int, -1> matrix;
    std::cout << matrix.size() << std::endl;
    auto a = matrix[1][1];
    std::cout << (a == -1) << std::endl;
    std::cout << matrix.size() << std::endl;
    matrix[100][100] = 314;
    std::cout << (matrix[100][100] == 314) << std::endl;
    std::cout << matrix.size() << std::endl;
    
    int x, y, v;
    std::tie(x,y,v) = matrix.begin();
    std::cout << x << y << v << std::endl;
    
    // std::cout << 
    // for(auto c: mat1) {
    //     int x, y, v;
    //     std::tie(x,y,v) = c;
    //     std::cout << x << y << v << std::endl;
    // }
    return 0;
}
