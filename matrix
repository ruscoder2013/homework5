#include <iostream>
#include <map>
#include <tuple>

template<typename T, int default_number>
class Matrix {
public:
    class IntAdapter {
    friend class Matrix;
    public:
        IntAdapter(Matrix &parent, int row, int col) : 
            parent(parent),
            row(row),
            col(col)
        { }
        operator int() { 
            if ( parent.mat.find(row) != parent.mat.end() )
                 {
                     if ( parent.mat[row].find(col) != parent.mat[row].end()) {
                         return parent.mat[row][col];
                     }
                }
            return default_number;
        }
        int& operator =(const int &a) 
        {
            if (a == default_number)
             {
                  if ( parent.mat.find(row) != parent.mat.end() )
                 {
                     if ( parent.mat[row].find(col) != parent.mat[row].end()) {
                         parent.mat[row].erase(col);
                         if (parent.mat[row].size() == 0)
                            parent.mat.erase(row);
                     }
                }
             }
            else
            {
                //std::cout << "don't equal" << std::endl;
                parent.mat[row][col] = a;
            }
            return (int&)a;
        }
    private:
        Matrix& parent;
        int row;
        int col;
    };
    class RowProxy {
    friend class Matrix;
    public:
        RowProxy(Matrix &parent, int row) : 
            parent(parent),
            row(row)
        { }
        
        IntAdapter operator[](int col)
        {
             if ( parent.mat.find(row) != parent.mat.end() )
             {
                 if ( parent.mat[row].find(col) != parent.mat[row].end()) {
                    // std::cout << "exist" << std::endl;
                     return IntAdapter(parent, row, col);
                 }
            }
            return IntAdapter(parent, row, col);
        }
    private:
        Matrix& parent;
        int row;
    };
    class iterator
	{
		friend class Matrix; 
	public:
 		iterator(Matrix &parent, 
 		 std::map<int, std::map<int, int>>::iterator it_1,
	    std::map<int,int>::iterator it_2
	    ) :parent(parent), it(it_1), it2(it_2) {
	        std::cout << "new" << std::endl;
	        //std::cout << it_2->first << std::endl;
	    }
// 		iterator(Double_node *dn): the_node(dn) {}
// 		iterator(const iterator &it): the_node(it.the_node)
// 		{}
		iterator& operator=(const iterator &iter)
		{
		    std::cout << "operator =" << std::endl;
		    it = iter.it;
		    it2 = iter.it2;
			return *this;
		}
		bool operator == (const iterator &iter) const
		{
		    std::cout << "operator ==" << std::endl;
		    if(it != parent.mat.end())
			    return ((iter.it == it) && (iter.it2 == it2));
			else 
			    return (iter.it == it);
		}
		bool operator!=(const iterator &it) const
		{
			return !(it == *this);
		}
		iterator& operator++()
		{
		    std::cout << "operator ++" << it2->first << std::endl;
		    it2 = ++it2;
		    std::cout << "operator ++" << it2->first << std::endl;
		    if(it2 != it->second.end())
		    {
		        std::cout << "it2 != it->second.end()" << std::endl;
		        std::cout << it->second.begin()->first << std::endl;
		        return *this;
		    }
		    else {
		        it++;
		        std::cout << "it++" << std::endl;
		        if(it != parent.mat.end())
		        {
		            it2 = it->second.begin();
		        }
		        return *this;
		    }
		}

		//переводит итератор на предідущий узел списка. 
		iterator & operator--()
		{
			return *this;
		}
		
		std::tuple<int, int, int> operator*() const
		{
            int a = it->first;
            int b = it2->first;
            int c = it2->second;
            return std::make_tuple(a, b, c);
		}

	private:
	    std::map<int, std::map<int, int>>::iterator it;
	    std::map<int,int>::iterator it2;
	    Matrix& parent;
	};
	
    int size() {
        int size = 0;
        for(const auto& row : mat)
        {
            size += row.second.size();   
        }
        return size;
    }
    RowProxy operator[](int row)
    {
        return RowProxy(*this, row);
    }
    // std::tuple<int, int, int> begin() {
    //     auto it = mat.begin();
    //     int a = it->first;
    //     auto it2 = it->second.begin();
    //     int b = it2->first;
    //     int c = it2->second;
    //     return std::make_tuple(a, b, c);
    // }
    // auto end() {
    //     return mat.end();
    // }
    
    iterator begin() {
        std::cout << "begin()" << std::endl;
        auto it_1 = mat.begin();
        auto it_2 = it_1->second.begin();
        iterator it(*this, it_1, it_2);
        return it;
    }
    iterator end() {
        std::cout << "end()" << std::endl;
        auto it_1 = mat.end();
        auto it_2 = it_1->second.begin();
        iterator it(*this, it_1, it_2);
        return it;
    }
    
    std::map<int, std::map<int, int>> mat;
};


int main() {
    Matrix<int, -1> matrix;
    std::cout << matrix.size() << std::endl;
    auto a = matrix[1][1];
    std::cout << (a == -1) << std::endl;
    std::cout << matrix.size() << std::endl;
    matrix[100][100] = 314;
    std::cout << (matrix[100][100] == 314) << std::endl;
    std::cout << matrix.size() << std::endl;
    
    std::map<int, std::map<int, int>> mat;
    mat[1][2] = 12;
    mat[2][3] = 23;
    for(auto it: mat) {
        int a = it.first;
        for(auto it2: it.second) {
            int b = it2.first;
            int c = it2.second;
            std::cout << a << b << c << std::endl;
        }
    }
    
    for(auto c: matrix) {
        std::cout << "mat1" << std::endl;
        int x, y, v;
        std::tie(x,y,v) = c;
        std::cout << x << y << v << std::endl;
    }
    return 0;
}
